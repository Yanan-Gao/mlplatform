variables:
  PLUTUS_JAR_NAME: "plutus.jar"
  PLUTUS_MERGEREQUESTS_JAR_FOLDER: "s3://thetradedesk-mlplatform-us-east-1/libs/plutus/jars/mergerequests"
  PLUTUS_SNAPSHOTS_JAR_FOLDER: "s3://thetradedesk-mlplatform-us-east-1/libs/plutus/jars/snapshots"
  PLUTUS_PROD_JAR_FOLDER: "s3://thetradedesk-mlplatform-us-east-1/libs/plutus/jars/prod"
  PLUTUS_ASSEMBLY_OUT: "/builds/thetradedesk/mlplatform/plutus/target/scala-2.12/plutus.jar"
  SCALA_BUILD_IMAGE_2_13_0: "hseeberger/scala-sbt:8u212_1.2.8_2.13.0"


  #This workflow rule will prevent duplicate pipelines for merge request AND branch commits
  #BUT we should avoid defining workflow rules on the top level (repo) .gitlab-ci/yml because it seems to
  # have weird interactions with inherited job rules from each project
  #   If the pipeline is triggered by:
  #
  #   A merge request, run a merge request pipeline. For example, a merge request pipeline can be triggered by a push to a branch with an associated open merge request.
  #   A change to a branch, but a merge request is open for that branch, do not run a branch pipeline.
  #   A change to a branch, but without any open merge requests, run a branch pipeline.
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_COMMIT_BRANCH'
      
plutus:test:
  image: "$SCALA_BUILD_IMAGE_2_13_0"
  stage: test
  cache:
    policy: pull
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - "plutus/src/**/*"
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - "plutus/src/**/*"
  before_script:
    # we don't need to set up the machine for S3 in order to run tests
    - git checkout -B "$CI_COMMIT_REF_NAME" "$CI_COMMIT_SHA"
  script: 
    - pushd ./plutus/
    - sbt test
    - popd
    - echo "ran plutus_test"

plutus:push_bits_merge_request:
  image: "$SCALA_BUILD_IMAGE_2_13_0"
  stage: assembly_upload
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - "plutus/src/**/*"
  script:
    - pushd ./plutus/
    - sbt "set test in assembly := {}" clean assembly
    - DEST=${PLUTUS_MERGEREQUESTS_JAR_FOLDER}/${CI_COMMIT_REF_NAME}/${CI_PIPELINE_ID}-${CI_COMMIT_SHORT_SHA}
    - aws s3 cp ${PLUTUS_ASSEMBLY_OUT} ${DEST}/${PLUTUS_JAR_NAME}
    - popd
    - echo "ran plutus_push_bits_merge_request"

plutus:push_bits_master_snapshot:
  image: "$SCALA_BUILD_IMAGE_2_13_0"
  stage: assembly_upload
  rules:
    - if: $CI_COMMIT_BRANCH == "master"
      changes:
        - "plutus/src/**/*"
  script:
    - pushd ./plutus/
    - sbt "set test in assembly := {}" clean assembly
    - DEST=${PLUTUS_SNAPSHOTS_JAR_FOLDER}/${CI_COMMIT_REF_NAME}/${CI_PIPELINE_ID}-${CI_COMMIT_SHORT_SHA}
    - aws s3 cp ${PLUTUS_ASSEMBLY_OUT} ${DEST}/${PLUTUS_JAR_NAME}
    - popd
    - echo "ran plutus_push_bits_master_snapshot"

plutus:push_set_scripts:
  image: "$SCALA_BUILD_IMAGE"
  stage: assembly_upload
  when: manual
  script:
    - pushd ./plutus/
    - aws s3 cp ${SCRIPTS_SOURCE} ${SCRIPTS_DEST}
    - popd
    - echo "ran push_set_scripts"
  only:
    refs:
      - master
    changes:
      - "plutus/**/*"


plutus:deploy_release:
  image: "$SCALA_BUILD_IMAGE_2_13_0"
  stage: deploy
  rules:
    - if: $CI_COMMIT_BRANCH == "master"
      changes:
        - "plutus/src/**/*"
      when: manual
      allow_failure: false
  script:
    - pushd ./plutus/
    - sbt "set test in assembly := {}" clean assembly
    - aws s3 cp ${PLUTUS_ASSEMBLY_OUT} ${PLUTUS_PROD_JAR_FOLDER}/${PLUTUS_JAR_NAME}
    - popd
    - echo "ran plutus_deploy_release"
