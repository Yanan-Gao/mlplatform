variables:
  MLPLATFORM_COMMON_ASSEMBLY_OUT: "common/target/mlplatform-common.jar"
  MLPLATFORM_COMMON_JAR_NAME: "mlplatform-common.jar"

  MLPLATFORM_FEATURESTORE_ASSEMBLY_OUT: "fsclient/target/mlplatform-fsclient.jar"
  MLPLATFORM_FEATURESTORE_JAR_NAME: "mlplatform-fsclient.jar"

  MLPLATFORM_API_ASSEMBLY_OUT: "api/target/mlplatform-api.jar"
  MLPLATFORM_API_JAR_NAME: "mlplatform-api.jar"

  MLPLATFORM_MERGEREQUESTS_JAR_FOLDER: "s3://thetradedesk-mlplatform-us-east-1/libs/mlplatform/jars/mergerequests"
  MLPLATFORM_SNAPSHOTS_JAR_FOLDER: "s3://thetradedesk-mlplatform-us-east-1/libs/mlplatform/jars/snapshots"
  MLPLATFORM_PROD_JAR_FOLDER: "s3://thetradedesk-mlplatform-us-east-1/libs/mlplatform/jars/prod"

  MLPLATFORM_MAVEN_BUILD_IMAGE: "maven:3.8.1-jdk-8"

  MLPLATFORM_API_IMAGE_NAME: "mlplatform-api"

  #This workflow rule will prevent duplicate pipelines for merge request AND branch commits
  #BUT we should avoid defining workflow rules on the top level (repo) .gitlab-ci/yml because it seems to
  # have weird interactions with inherited job rules from each project
  #   If the pipeline is triggered by:
  #
  #   A merge request, run a merge request pipeline. For example, a merge request pipeline can be triggered by a push to a branch with an associated open merge request.
  #   A change to a branch, but a merge request is open for that branch, do not run a branch pipeline.
  #   A change to a branch, but without any open merge requests, run a branch pipeline.
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_COMMIT_BRANCH'

mlplatform:test:
  image: "$MLPLATFORM_MAVEN_BUILD_IMAGE"
  stage: test
  cache:
    policy: pull
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - "mlplatform/**/*"
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - "mlplatform/**/*"
  before_script:
    # we don't need to set up the machine for S3 in order to run tests
    - git checkout -B "$CI_COMMIT_REF_NAME" "$CI_COMMIT_SHA"
  script:
    - pushd ./mlplatform/
    - mvn test
    - popd
    - echo "ran mlplatform_test"

mlplatform:push_bits_merge_request:
  image: "$MLPLATFORM_MAVEN_BUILD_IMAGE"
  stage: assembly_upload
  artifacts:
    untracked: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - "mlplatform/**/*"
  script:
    - pushd ./mlplatform/
    - mvn -Dmaven.test.skip=true package
    - DEST=${MLPLATFORM_MERGEREQUESTS_JAR_FOLDER}/${CI_COMMIT_REF_NAME}/${CI_PIPELINE_ID}-${CI_COMMIT_SHORT_SHA}
    - aws s3 cp ${MLPLATFORM_COMMON_ASSEMBLY_OUT} ${DEST}/${MLPLATFORM_COMMON_JAR_NAME}
    - aws s3 cp ${MLPLATFORM_FEATURESTORE_ASSEMBLY_OUT} ${DEST}/${MLPLATFORM_FEATURESTORE_JAR_NAME}
    - aws s3 cp ${MLPLATFORM_API_ASSEMBLY_OUT} ${DEST}/${MLPLATFORM_API_JAR_NAME}
    - popd
    - echo "ran mlplatform_push_bits_merge_request"

mlplatform:push_bits_master_snapshot:
  image: "$MLPLATFORM_MAVEN_BUILD_IMAGE"
  stage: assembly_upload
  artifacts:
    untracked: true
  rules:
    - if: $CI_COMMIT_BRANCH == "master"
      changes:
        - "mlplatform/**/*"
  script:
    - pushd ./mlplatform/
    - mvn -Dmaven.test.skip=true package
    - DEST=${MLPLATFORM_SNAPSHOTS_JAR_FOLDER}/${CI_COMMIT_REF_NAME}/${CI_PIPELINE_ID}-${CI_COMMIT_SHORT_SHA}
    - aws s3 cp ${MLPLATFORM_COMMON_ASSEMBLY_OUT} ${DEST}/${MLPLATFORM_COMMON_JAR_NAME}
    - aws s3 cp ${MLPLATFORM_FEATURESTORE_ASSEMBLY_OUT} ${DEST}/${MLPLATFORM_FEATURESTORE_JAR_NAME}
    - aws s3 cp ${MLPLATFORM_API_ASSEMBLY_OUT} ${DEST}/${MLPLATFORM_API_JAR_NAME}
    - popd
    - echo "ran mlplatform_push_bits_master_snapshot"

mlplatform:deploy_api_dev_docker_image_merge_request:
  image: proxy.docker.adsrvr.org/docker:git
  stage: deploy
  dependencies:
    - mlplatform:push_bits_merge_request
  services:
    - docker:dind
  after_script:
    - docker logout ${DOCKER_PRODUCTION_REGISTRY}
    - docker logout ${DOCKER_DEV_REGISTRY}
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - "mlplatform/**/*"
      when: manual
      allow_failure: true # ugly but known issue - https://gitlab.com/gitlab-org/gitlab/-/issues/34077
  before_script:
    # override the default before script
    # we don't need to set up the machine for S3 in order to build and push the docker image
    - echo MLPLATFORM_API_IMAGE_NAME {MLPLATFORM_API_IMAGE_NAME}
    - echo DOCKER_DEV_REGISTRY ${DOCKER_DEV_REGISTRY}
    - DEV_IMAGE_PATH=${DOCKER_DEV_REGISTRY}/${MLPLATFORM_API_IMAGE_NAME}
    - echo DEV_IMAGE_PATH ${DEV_IMAGE_PATH}
    - DEV_IMAGE_PATH_SHA=${DEV_IMAGE_PATH}:${CI_COMMIT_SHORT_SHA}
    - echo DEV_IMAGE_PATH_SHA ${DEV_IMAGE_PATH_SHA}
    - DEV_IMAGE_PATH_LATEST=${DEV_IMAGE_PATH}:latest
    - echo DEV_IMAGE_PATH_LATEST ${DEV_IMAGE_PATH_LATEST}
  script:
    - cd ./mlplatform/api
    - echo "logging in to ${DOCKER_DEV_REGISTRY}"
    - docker login ${DOCKER_DEV_REGISTRY} -u ${DOCKER_DEV_USER} -p ${DOCKER_DEV_PASS}
    - docker build -t ${DEV_IMAGE_PATH_SHA} .
    - docker push ${DEV_IMAGE_PATH_SHA}
    - echo "ran deploy_api_dev_docker_image_merge_request"

mplatform:deploy_api_dev_k8s_merge_request:
  image: ${DOCKER_PRODUCTION_REGISTRY}/ttd-pipeline/kubectl-kustomize:1.0.2
  stage: k8s_deploy
  dependencies:
    - mlplatform:deploy_api_dev_docker_image_merge_request
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - "mlplatform/**/*"
      when: manual
      allow_failure: true # ugly but known issue - https://gitlab.com/gitlab-org/gitlab/-/issues/34077
  before_script:
    - mkdir -p /root/.kube
    - kubectl config set clusters.general-use-non-production.certificate-authority-data $EKS_NON_PROD_CRT
    - kubectl config set-credentials $EKS_NON_PROD_USER
    - kubectl config set-context general-use-non-production --cluster=general-use-non-production --user=$EKS_NON_PROD_USER --namespace mlplatform
    - kubectl config use-context general-use-non-production
    - kubectl config set-credentials $EKS_NON_PROD_USER --token=$EKS_NON_PROD_TOKEN
    - kubectl config set-cluster general-use-non-production --server $EKS_NON_PROD_URL
    - DEV_IMAGE_PATH=${DOCKER_DEV_REGISTRY}/${MLPLATFORM_API_IMAGE_NAME}
    - echo DEV_IMAGE_PATH ${DEV_IMAGE_PATH}
    - DEV_IMAGE_PATH_SHA=${DEV_IMAGE_PATH}:${CI_COMMIT_SHORT_SHA}
    - echo DEV_IMAGE_PATH_SHA ${DEV_IMAGE_PATH_SHA}
  script:
    # set kubectl ./mlplatform/k8s/feature-store/api/overlays/sandbox
    - cd ./mlplatform/k8s/feature-store/api/overlays/sandbox
    - echo setting image to ${DEV_IMAGE_PATH_SHA}
    - kustomize edit add secret test-db-user-credentials --from-literal=password=${MLPLATFORM_TEST_DB_PASSWORD} && kustomize edit add secret test-db-user-credentials --from-literal=username=${MLPLATFORM_TEST_DB_USERNAME}
    - kustomize edit set image mlplatform-api=${DEV_IMAGE_PATH_SHA} && kustomize edit add annotation gitLabJobId:${CI_JOB_ID}
    - kustomize build . | kubectl apply -f -
    # wait for deployment to succeed before calling this a success
    - >
      if ! kubectl rollout status deployment mlplatform-api; then
        kubectl rollout undo deployment mlplatform-api
        exit 1
      fi
    - echo "ran deploy_api_dev_k8s_merge_request"

mlplatform:deploy_jar_release:
  image: "$MLPLATFORM_MAVEN_BUILD_IMAGE"
  stage: deploy
  rules:
    - if: $CI_COMMIT_BRANCH == "master"
      changes:
        - "mlplatform/**/*"
      when: manual
  script:
    - pushd ./mlplatform/
    - mvn -Dmaven.test.skip=true package
    - aws s3 cp ${MLPLATFORM_COMMON_ASSEMBLY_OUT} ${MLPLATFORM_PROD_JAR_FOLDER}/${MLPLATFORM_COMMON_JAR_NAME}
    - aws s3 cp ${MLPLATFORM_FEATURESTORE_ASSEMBLY_OUT} ${MLPLATFORM_PROD_JAR_FOLDER}/${MLPLATFORM_FEATURESTORE_JAR_NAME}
    - aws s3 cp ${MLPLATFORM_API_ASSEMBLY_OUT} ${MLPLATFORM_PROD_JAR_FOLDER}/${MLPLATFORM_API_JAR_NAME}
    - popd
    - echo "ran mlplatform_deploy_jar_release"
